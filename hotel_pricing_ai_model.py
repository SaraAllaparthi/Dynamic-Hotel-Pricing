# -*- coding: utf-8 -*-
"""Hotel Pricing AI Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bQKrOM4Lc28enJdUi_fUYoyGx4Ie7FsE

# 1. Install Required Libraries
"""


"""# 2. Import Libraries and Upload Your Data"""


import streamlit as st
import pandas as pd
import os

# Construct the file path (assuming hotel_bookings.csv is in the same folder as your app)
file_path = os.path.join(os.path.dirname(__file__), "hotel_bookings.csv")

try:
    df = pd.read_csv(file_path)
    st.success("Data loaded successfully!")
    st.dataframe(df.head())
except FileNotFoundError:
    st.error(f"File not found at: {file_path}")



df.head()  # Display the first few rows of the DataFrame

"""# 3. Preprocess the Data"""

import pandas as pd

# --- If you haven't loaded your data yet, uncomment one of the following methods ---

# Method 1: Manual Upload (if not already done)
# from google.colab import files
# uploaded = files.upload()
# import io
# df = pd.read_csv(io.BytesIO(uploaded['hotel_bookings.csv']))

# Method 2: Using Google Drive (if file is stored on your Drive)
# from google.colab import drive
# drive.mount('/content/drive')
# file_path = '/content/drive/My Drive/ColabData/hotel_bookings.csv'
# df = pd.read_csv(file_path)

# --- Process the Data ---

# 1. Convert the reservation_status_date column to datetime
df['reservation_status_date'] = pd.to_datetime(df['reservation_status_date'])

# 2. Filter out canceled bookings
#    (Assuming that is_canceled == 0 means the booking was not canceled)
df_not_canceled = df[df['is_canceled'] == 0]

# 3. Compute daily occupancy by grouping by the reservation date and counting bookings
occupancy = df_not_canceled.groupby('reservation_status_date').size().reset_index(name='occupancy')

# 4. Prepare the data for Prophet: rename columns to 'ds' (date) and 'y' (value)
prophet_df = occupancy.rename(columns={'reservation_status_date': 'ds', 'occupancy': 'y'})

# 5. Display the first few rows of the processed data
print("Processed occupancy data (first 5 rows):")
print(prophet_df.head())

"""# 4. Fit the Prophet Forecasting Model"""

# Initialize and fit the Prophet model
model = Prophet(daily_seasonality=True)
model.fit(prophet_df)

# Define the forecast horizon (e.g., next 30 days)
forecast_periods = 30
future = model.make_future_dataframe(periods=forecast_periods)

# Generate the forecast
forecast = model.predict(future)

# Show the tail of the forecast DataFrame
forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()

"""# 5. Visualize the Forecast"""

# Plot the forecast using Prophet's built-in plotting function
fig1 = model.plot(forecast)
plt.title("Occupancy Forecast")
plt.xlabel("Date")
plt.ylabel("Predicted Occupancy")
plt.show()

# (Optional) Plot forecast components (trend, weekly seasonality, etc.)
fig2 = model.plot_components(forecast)
plt.show()

"""# 6. Evaluate Forecast Accuracy"""

from prophet.diagnostics import cross_validation, performance_metrics

# Perform cross-validation: forecast horizon of 30 days, initial training period of 90 days,
# and a period between forecasts of 15 days. Adjust these parameters as needed.
df_cv = cross_validation(model, initial='90 days', period='15 days', horizon = '30 days')
df_p = performance_metrics(df_cv)

# Display performance metrics (e.g., MAE, RMSE)
df_p.head()

"""## Feature 1: Competitor-Based Dynamic Pricing"""

# ============================
# Additional Features Section
# ============================

# Feature 1: Competitor-Based Dynamic Pricing
import pandas as pd
import numpy as np

def competitor_dynamic_pricing():
    # Simulate competitor data (in production, you might scrape or use an API)
    competitor_data = pd.DataFrame({
        'hotel': ['Competitor A', 'Competitor B', 'Competitor C'],
        'rate': [120.0, 135.0, 110.0],
        'occupancy_rate': [0.85, 0.90, 0.80]
    })
    print("### Competitor Data")
    display(competitor_data)

    # Calculate a base recommendation
    avg_competitor_rate = competitor_data['rate'].mean()
    avg_competitor_occ = competitor_data['occupancy_rate'].mean()
    adjustment_factor = 1 + (avg_competitor_occ - 0.85)  # dummy adjustment
    recommended_price = avg_competitor_rate * adjustment_factor
    print(f"Recommended Base Price based on competitors: ${recommended_price:.2f}")

# Run competitor-based pricing feature
competitor_dynamic_pricing()

"""# Feature 2: Demand Forecasting for High and Low Seasons with Event/Holiday Input"""

# Feature 2: Demand Forecasting for High and Low Seasons with Event/Holiday Input

from prophet import Prophet
import matplotlib.pyplot as plt

def demand_forecasting_with_events(prophet_df):
    # Allow the user to define event/holiday dates (hardcoded here for demonstration)
    event_dates = ['2015-07-04', '2015-12-25']
    holidays = pd.DataFrame({
        'holiday': 'event',
        'ds': pd.to_datetime(event_dates),
        'lower_window': 0,
        'upper_window': 1,
    })
    print("### Events/Holidays for Forecast:")
    display(holidays)

    # Initialize Prophet with holidays
    model = Prophet(holidays=holidays, daily_seasonality=True)
    model.fit(prophet_df)

    forecast_periods = 30  # for example, forecast the next 30 days
    future = model.make_future_dataframe(periods=forecast_periods)
    forecast = model.predict(future)

    print("### Forecast Data (tail):")
    display(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail())

    # Plot forecast
    fig = model.plot(forecast)
    plt.title("Demand Forecast with Events")
    plt.xlabel("Date")
    plt.ylabel("Predicted Occupancy")
    plt.show()

# Assuming you have already preprocessed your data for Prophet as `prophet_df`
# For example, if you followed previous steps:
# prophet_df = preprocess_occupancy_data(df)
# Then run the forecasting with events:
demand_forecasting_with_events(prophet_df)

"""## Feature 3: Personalized Promotions"""

# Feature 3: Personalized Promotions

def personalized_promotions():
    # Simulated customer segmentation data
    customer_data = pd.DataFrame({
        'customer_type': ['Transient', 'Contract', 'Group', 'Transient', 'Transient'],
        'average_spend': [100, 150, 80, 120, 90]
    })
    print("### Customer Data Sample")
    display(customer_data)

    # Define promotions based on customer segment
    promotions = {
        'Transient': 'Offer 10% off for early bookings',
        'Contract': 'Provide a complimentary room upgrade',
        'Group': 'Offer special group discounts'
    }
    # For demonstration, choose a segment (you could make this interactive)
    chosen_segment = 'Transient'
    print(f"Suggested promotion for {chosen_segment} customers: {promotions[chosen_segment]}")

# Run the personalized promotions feature
personalized_promotions()

"""## Feature 4: Length-of-Stay (LOS) Optimization"""

# Feature 4: Length-of-Stay (LOS) Optimization

def los_optimization():
    # Simulated LOS data; in a real scenario, you would analyze stays_in_weekend_nights and stays_in_week_nights
    los_data = pd.DataFrame({
        'LOS (nights)': [1, 2, 3, 4, 5, 6],
        'average_rate': [100, 95, 90, 85, 80, 75]
    })
    print("### Historical LOS Data")
    display(los_data)

    # Find the optimal LOS (where average_rate is maximized)
    optimal_index = los_data['average_rate'].idxmax()
    optimal_los = los_data.loc[optimal_index, 'LOS (nights)']
    print(f"Optimal Length of Stay: {optimal_los} nights")
    print("Consider incentivizing this LOS with special pricing or packages.")

# Run LOS optimization
los_optimization()

"""# Feature 5: Room Upgrade and Cross-Selling Suggestions"""

# Feature 5: Room Upgrade and Cross-Selling Suggestions

def room_upgrade_suggestions():
    # Simulated booking history data
    booking_data = pd.DataFrame({
        'guest_id': [1, 2, 3, 4, 5],
        'current_room_type': ['Standard', 'Standard', 'Deluxe', 'Standard', 'Suite'],
        'past_upgrade': [False, True, False, False, True]
    })
    print("### Booking Data")
    display(booking_data)

    # Identify guests who have not yet had an upgrade
    suggestions = booking_data[booking_data['past_upgrade'] == False]
    print("### Room Upgrade Suggestions for Guests:")
    display(suggestions[['guest_id', 'current_room_type']])
    print("Consider offering packages (e.g., breakfast or spa) to encourage upgrades.")

# Run room upgrade suggestions
room_upgrade_suggestions()

"""# Feature 6: Price Sensitivity Analysis"""

# Feature 6: Price Sensitivity Analysis

def price_sensitivity_analysis():
    # Simulated pricing vs. conversion data
    pricing_data = pd.DataFrame({
        'price': [80, 90, 100, 110, 120, 130],
        'conversion_rate': [0.9, 0.88, 0.85, 0.8, 0.75, 0.7]
    })
    print("### Pricing and Conversion Data")
    display(pricing_data)

    # Identify threshold where conversion rate falls below a target (e.g., 0.8)
    threshold = pricing_data[pricing_data['conversion_rate'] < 0.8]['price'].min()
    if pd.isna(threshold):
        print("No significant drop in conversion rate detected.")
    else:
        print(f"Price sensitivity threshold detected at: ${threshold}")
        print("Consider setting room rates below this threshold to maintain bookings.")

# Run price sensitivity analysis
price_sensitivity_analysis()

"""# Feature 7: Last-Minute Pricing Adjustments"""

# Feature 7: Last-Minute Pricing Adjustments

def last_minute_pricing():
    # Simulate inputs for unsold inventory and current base price
    unsold_inventory = 5  # For example, 5 rooms unsold
    current_price = 100.0
    print(f"Current unsold inventory: {unsold_inventory} rooms")
    print(f"Current base price: ${current_price}")

    # Apply a simple rule: if unsold inventory exists, reduce price by 10%
    if unsold_inventory > 0:
        adjusted_price = current_price * 0.9
        print(f"Suggested last-minute price adjustment: ${adjusted_price:.2f}")
    else:
        print("No adjustments needed for last-minute pricing.")

# Run last-minute pricing adjustment
last_minute_pricing()

"""# Feature 8: Competitor Benchmarking Dashboard"""

# Feature 8: Competitor Benchmarking Dashboard

def competitor_benchmarking_dashboard():
    # Simulated competitor benchmark data
    competitor_data = pd.DataFrame({
        'hotel': ['Competitor A', 'Competitor B', 'Competitor C', 'Our Hotel'],
        'price': [120, 135, 110, 125],
        'occupancy_rate': [0.85, 0.90, 0.80, 0.88]
    })
    print("### Competitor Benchmarking Data")
    display(competitor_data)

    # Plotting competitor prices
    import matplotlib.pyplot as plt
    fig, ax = plt.subplots()
    ax.bar(competitor_data['hotel'], competitor_data['price'], color=['blue', 'green', 'red', 'purple'])
    ax.set_ylabel("Room Price")
    ax.set_title("Competitor Room Prices")
    plt.show()

# Run competitor benchmarking dashboard
competitor_benchmarking_dashboard()
